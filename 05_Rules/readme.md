# Rules

- there are different kinds of rules

  1. Explicit rules:
     default kind rules, just like previous we have writing, most common.

  2. Pattern rules:
     use wildcards instead of explicit filenames
     allow `make` apply the rules anytime a target file matching the Pattern need to updated

  3. Implicit rules:
     either `Pattern rules` or `suffix rules`
     found in the rules database build-in `make`
     make write `Makefile` easier, since `make` alreay knows the files types suffix, and programs for updating target

  4. static rules:
     like Pattern rules, except they apply to specific list of target files.

### Explicit rules

     * most rules are explicit rules that specify target, and prerequisites.
     * a rule can have more than one target.

     ```Makefile
     vpath.o variable.o:make.h config.h getopt.h gettext.h dep.h
     ```
    have the same effect:

     ```Makefile
     vpath.o :make.h config.h getopt.h gettext.h dep.h

     variable.o:make.h config.h getopt.h gettext.h dep.h
     ```
     * you don't have to write down all the prerequisites or target all at once
     if a target is been seen before, after the same target, all the prerequisites will be append to the same target
     and it can improve the readability.

     ```Makefile
     vpath.o: vpath.c make.h config.h getopt.h gettext.h dep.h
     vpath.o: filedef.h hash.h job.h commands.h variable.h vpath.h
     ```

     * the prerequisites list can be composed of files that are managed vary differently

     ```Makefile
     # Make sure lexer.c is created before vpath.c is compiled.
     vpath.o: lexer.c
     ...

     # Compile vpath.c with special flags.
     vpath.o: vpath.c
     $(COMPILE.c) $(RULE_FLAGS) $(OUTPUT_OPTION) $<
     ...
     # Include dependencies generated by a program.
     include auto-generated-dependencies.d

     ```
